<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="raaaay.github.io : Now, Welcome to Raaaay's Blog!" />

    <link rel="stylesheet" type="text/css" media="screen" href="../stylesheets/stylesheet.css">

    <title>初识FastCGI</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
			<h1 id="project_title">hello, Mr.Chan!</h1>
			<h2 id="project_tagline">Now, Welcome to Raaaay's Blog!</h2>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
		<section id="main_content" class="inner">
			<h2>1. 初识FastCGI</h2>
			注：本文主要翻译自<a href="http://www.fastcgi.com/drupal/node/6?q=node/15" target="_blank">
			http://www.fastcgi.com/drupal/node/6?q=node/15</a>
			<p>FastCGI是一个<em>高效、开放、安全</em>的Web服务器接口，它很好地解决了CGI的性能问题，并且对其API并未引入额外负荷或复杂度。
			<blockquote>FastCGI is a fast, open, and secure Web server interface that solves the performance problems inherent in CGI, 
			without introducing the overhead and complexity of proprietary APIs (Application Programming Interfaces).</blockquote>
			</p>
			<p>
			<h3>CGI有什么好处</h3>
			<ul>
			<li><em>简单</em>。易于理解。</li>
			<li><em>语言无关</em>。几乎可以用任何语言实现。</li>
			<li><em>进程独立</em>。进程间是相互独立的，一个application的bug不会导致整个server的crash。</li>
			<li><em>公开标准</em>。某些CGI的形式基本上被所有的浏览器支持。</li>
			<li><em>架构无关</em>。CGI没有与任何服务器架构绑定。</li>
			</ul>
			但是，CGI也有不少缺点，首当其冲的就是它的<em>效率</em>及其低下。它会为每一个请求都创建一个进程，然后在请求结束的时候释放掉。
			为了解决CGI的性能问题，某些服务器供应商专门为他们的服务器开发了API，最著名的就是网景和微软，但是效果始终不够理想，因为它们
			几乎毁掉了CGI所有的优点。
			</p>
			<p>
			<h3>FastCGI</h3>
			FastCGI综合了CGI和供应商API所有的优点，它的好处显而易见：
			<ul>
			<li><em>高性能</em></li>
			<li><em>简单，易于与CGI融合</em></li>
			<li><em>进程独立</em></li>
			<li><em>语言无关</em></li>
			<li><em>非定制</em></li>
			<li><em>架构无关</em></li>
			<li><em>支持分布式计算</em></li>
			</ul>
			</p>
			
			<h2>2. FastCGI接口</h2>
			<p>FastCGI提供的接口与CGI非常的类似，为此，我们首先来了解一下CGI都提供了哪些接口。</p>
			<ul>
			<li><em>对于每一个请求，服务器都创建一个进程（非线程）并且该进程自初始化。</em></li>
			<li><em>web服务器将请求信息（如远程主机，用户，http header等）以环境变量的形式传递给CGI程序。</em></li>
			<li><em>web服务器将任何客户端输入（如表单数据等）发送给CGI程序标准输入。</em></li>
			<li><em>CGI程序将任何输出以标准输出方式返回给客户端，错误信息以标准错误形式返回并被web服务器记录。</em></li>
			<li><em>CGI进程结束时，代表请求完成。</em></li>
			</ul>
			FastCGI的概念与CGI非常的类似，主要只有两点区别：
			<blockquote>
			<ul>
			<li>FastCGI processes are persistent: after finishing a request, they wait for a new request instead of exiting.</li>
			<li>Instead of using operating system environment variables and pipes, the FastCGI protocol multiplexes the environment information, standard input, output and error over a single full-duplex connection. This allows FastCGI programs to run on remote machines, using TCP connections between the Web server and the FastCGI application. </li>
			</ul>
			</blockquote>
			在一个单线程的FastCGI应用中的请求处理过程如下：
			<ul>
			<li><em>web服务器创建一个FastCGI进程来处理请求，该进程可能是启动的时候就已经创建，也可能是应要求而创建。</em></li>
			<li><em>FastCGI程序自初始化，并且等待来自web服务器的连接。</em></li>
			<li><em>当有请求来到时，web服务器打开一个与FastCGI进程的连接，并且将CGI环境变量和标准输入通过该连接进行传输。</em></li>
			<li><em>FastCGI进程通过相同的连接返回标准输出及错误信息。</em></li>
			<li><em>当FastCGI进程关闭连接时，请求结束。FastCGI进程会等待来自web服务器的下一个连接。</em></li>
			</ul>
			FastCGI可以在本地或者远程运行，分别采用的是全双工通道和TCP连接。FastCGI也可以是单线程或者多线程程序。
			
			<h2>3. FastCGI协议</h2>
		</section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-46282390-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
